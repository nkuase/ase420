---
marp: true
---

# Q04. Factory Method Pattern

---

## Question 4.1

It provides a way to create objects without specifying the exact class of object that will be created, delegating the instantiation logic to subclasses.

What design pattern solves this problem?

---

**Answer:**


---

## Question 4.2

**Simple factory**: Uses a single class with conditional logic to create objects.
**Factory Method**: Uses ??? - each concrete creator subclass implements its own factory method.

This is the main difference between a simple factory and the Factory Method pattern. What is ???

---

**Answer:**


---

## Question 4.3

What are the main participants (abstract only) in the Factory Method pattern?

1. **??1** - declares the factory method
3. **??2** - defines the interface for products

---

**Answer:**


---

## Question 4.4

This is the code that uses the Factory Method when we use ConcreteProduct() to make the concrete product:

```python
c = ConcreteCreator()
p = c.create_product()
```

Complete the Factory Method pattern structure:

```python
class Creator:
    def ??1(self):  # Factory method
        pass

class ConcreteCreator(Creator):
    def ??1(self):
        return ConcreteProduct()
```

---

**Answer:**


---

## Question 4.5

(T/F) In the Factory Method pattern, the abstract creator class depends on concrete product classes to make products.

---

**Answer:**


---

## Question 4.6

(T/F) The Factory Method follows DIP (Dependency Inversion Principle) because it depend on abstractions, not concretions.

The creator depends on the abstract Product interface, not concrete implementations.

---

**Answer:**


---

## Question 4.7

What is a "parameterized factory method"?

---

**Answer:**


---

## Question 4.8

- When a class can't anticipate the class of objects it must create
- When a class wants its subclasses to specify the objects it creates
- When you want to localize the knowledge of which class to instantiate
- When you want to remove all subclassing and keep everything in one class  

This is a list of when we should use the Factory Method pattern; which is wrong?

---

**Answer:**


---

## Question 4.9

1. **Eliminates coupling** between creator and concrete products
2. **Single Responsibility** - object creation is separated from usage
3. **Open/Closed Principle** - can add new products without changing existing code
4. **Promotes consistency** - ensures objects are created properly
5. **Improves performance** â€” creation logic is always faster  

This is a list of the benefits of the Factory Method pattern. Which is wrong?

---

**Answer:**


---

## Question 4.10

What is the difference between Factory Method and Abstract Factory patterns?

---

**Answer:**


---

## Question 4.11

Complete the client code for Factory Method:

```python

class Factory(): def create_factory(): ...
class Product(): def use(): ...
class ConcreterFactory(Factory): ...
class ConcreteProduct(Product): ...

# Usage
factory = ??()
product = factory.??()
product.??()
```

---

**Answer:**


---

## Summary

We have 11 questions on this page.

1. How many questions did you answer? ( / 11)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
