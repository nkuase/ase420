---
marp: true
---

# Q14. Chain of Responsibility Pattern

---

## Question 1

To pass requests along a chain of handlers until one of them handles the request, avoiding coupling between sender and receiver.  

What pattern explains this idea?

---

**Answer:**  


---

## Question 2

This is a list of the main participants in the **Chain of Responsibility pattern**.  
Which one is **wrong**?

1. **Handler** - interface for handling requests and accessing successor
2. **ConcreteHandler** - handles requests it's responsible for, forwards others to successor
3. **Client** - initiates request to any handler in the chain
4. **Provider** — belongs to **Handler**

---

**Answer:**


---

## Question 3

Complete the Chain of Responsibility pattern:

```python
class SupportHandler:
    def set_next(self, next_support):
        self.next = ???
    
    def support(self, trouble):
        if self.resolve(trouble):
            self.done(trouble)
        elif self.next is not None:
            self.next.???(trouble)
```

---

**Answer:**


---

## Question 4

How do you set up the chain?

```python
class SupportHandler:  # Handler
    def set_next(self, next_support): ...
    def support(self, trouble): ...

level1 = Level1Support()
level2 = Level2Support()
level3 = Level3Support()

level1.??1(level2)
level2.??1(level3)

# Start the chain
level1.??2(Request(2))
```

---

**Answer:**


---

## Question 5

(T/F) In Chain of Responsibility, the sender knows which object will handle the request.

---

**Answer:**


---

## Question 6

This is a list of when we should use the **Chain of Responsibility pattern**.  
Which one is **wrong**?

- When you need to **guarantee exactly one handler** will process the request
- When **multiple objects** can handle a request but you don't know which one in advance
- When you want to **decouple senders from receivers**
- When the set of handlers should be **specified dynamically**
- When you want to pass requests through a **hierarchy** of handlers

---

**Answer:**


---

## Question 7

This is a list of the benefits of the **Chain of Responsibility pattern**.  
Which one is **wrong**?

1. **Reduced coupling** - sender doesn't need to know receiver
2. **Flexible chains** - can add/remove handlers dynamically  
3. **Single Responsibility** - each handler focuses on one type of request
4. **Runtime configuration** - can modify chain at runtime
5. **Guarantees a request will be handled** — requests sure to be handled

---

**Answer:**


---

## Question 8

This is a list of potential drawbacks of the **Chain of Responsibility pattern**.  
Which one is **wrong**?

1. **No guarantee of handling** - request might not be handled
2. **Performance issues** - long chains can be slow
3. **Debugging difficulty** - hard to trace request flow
4. **Runtime errors** - misconfigured chains can cause problems
5. **Ensures only one handler processes the request** — multiple handlers process it if designed that way

---

**Answer:**


---

## Question 9

**Chain of Responsibility**: **One** handler processes the request, others pass it along.
**Decorator**: **All** decorators process the request, adding their own behavior.

(T/F) This explains the difference between Chain of Responsibility and Decorator patterns correctly.

---

**Answer:**


---

## Summary

We have 9 questions on this page.

1. How many questions did you answer? ( / 9)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
