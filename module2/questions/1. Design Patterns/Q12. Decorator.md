---
marp: true
---

# Q12. Decorator Pattern

---

## Question 12.1

To attach additional responsibilities to objects dynamically without altering their structure, providing a flexible alternative to subclassing.

What pattern explains this idea?

---

**Answer:**


---

## Question 12.2

What are the two main participants in the Decorator pattern?

---

**Answer:**


---

## Question 12.3

What is the relationship between the Component and Decorator in the Decorator pattern?

---

**Answer:**


---

## Question 12.4

(T/F) Decorator pattern allows behavior to be extended without using inheritance.

---

**Answer:**


---

## Question 12.5

**Inheritance**: **Static** composition, behavior fixed at compile time, can lead to class explosion.
**Decorator**: **Dynamic** composition, behavior can be combined at runtime, flexible combinations.

(T/F) This explains the difference between Decorator and Inheritance correctly.

---

**Answer:**


---

## Question 12.6

This is a list of when we should use the **Decorator pattern**.  
Which one is **wrong**?

- When you want to add responsibilities **dynamically** and **transparently**
- When extension by subclassing is **impractical** (class explosion)
- When you need **flexible combinations** of features
- When you want to add features **without affecting other objects**
- When you want to **guarantee only one instance** of a class

---

**Answer:**


---

## Question 12.7

This is a list of the benefits of the **Decorator pattern**.  
Which one is **wrong**?

1. **Runtime composition** - can combine behaviors dynamically
2. **Avoids class explosion** - no need for all feature combinations
3. **Single Responsibility** - each decorator has one additional feature
4. **Open/Closed Principle** - can extend without modifying existing code
5. **Flexible combinations** - mix and match decorators
6. **Improves raw performance** — Decorator adds indirection and may speed things up  

---

**Answer:**


---

## Question 12.8

This is a list of potential drawbacks of the **Decorator pattern**.  
Which one is **wrong**?

1. **Lots of small objects** - many small decorator objects
2. **Complex debugging** - hard to trace through decorator chain
3. **Identity issues** - decorated object != original object
4. **Order dependency** - decorator order can affect behavior
5. **Prevents adding new behavior** — decorator focuses on the main element

---

**Answer:**


---

## Question 12.9

In Java I/O streams, what design pattern is used?

```java
FileInputStream fis = new FileInputStream("file.txt");
BufferedInputStream bis = new BufferedInputStream(fis);
DataInputStream dis = new DataInputStream(bis);
```

---

**Answer:**


---

## Summary

We have 9 questions on this page.

1. How many questions did you answer? ( / 9)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
