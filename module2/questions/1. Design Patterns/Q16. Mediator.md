---
marp: true
---

# Q16. Mediator Pattern

---

## Question 16.1

To define how a set of objects interact by keeping objects from referring to each other explicitly, promoting loose coupling by centralizing complex communications.  

What pattern explains this idea?

---

**Answer:**  


---

## Question 16.2

It prevents **tight coupling** between objects that need to communicate and avoids **many-to-many relationships** by centralizing communication through a mediator.

What pattern solves this problem?

---

**Answer:**


---

## Question 16.3

This is a list of the main participants in the **Mediator pattern**.  
Which one is **wrong**?

1. **Mediator** - interface defining communication contract
2. **ConcreteMediator** - implements mediator and coordinates colleague behavior
3. **Colleague** - classes that communicate through mediator instead of directly
4. **Visitor** — searches for the correct element for mediate

---

**Answer:**


---

## Question 16.4

(T/F) In Mediator pattern, colleagues communicate directly with each other.

---

**Answer:**


---

## Question 16.5

This is a list of when we should use the **Mediator pattern**.  
Which one is **wrong**?

- When objects communicate in **complex but well-defined ways**
- When **reusing objects is difficult** due to many references to other objects
- When behavior distributed between classes should be **customizable** without subclassing
- When you want to **centralize complex communications**
- When you want to **share intrinsic state among objects**

---

**Answer:**


---

## Question 16.6

This is a list of the benefits of the **Mediator pattern**.  
Which one is **wrong**?

1. **Decouples colleagues** - objects don't reference each other directly
2. **Centralizes control** - complex logic is in one place
3. **Simplifies object protocols** - one-to-many instead of many-to-many
4. **Promotes reusability** - colleagues can be reused more easily
5. **Makes behavior explicit** - communication logic is visible
6. **Minimizes memory usage** — effective resrouce usage

---

**Answer:**


---

## Question 16.7

This is a list of potential drawbacks of the **Mediator pattern**.  
Which one is **wrong**?

1. **Mediator complexity** - mediator can become complex and hard to maintain
2. **Single point of failure** - if mediator fails, communication breaks
3. **Performance bottleneck** - all communication goes through mediator
4. **God object risk** - mediator might try to do too much
5. **Prevents adding new communication rules** — Mediator makes it *hard* to add or change rules among elements

---

**Answer:**


---

## Question 16.8

In a chat room example, identify the Mediator components:

```python
class ChatRoom:
    def send_message(self, message, user):
        # Send to all other users
        pass

class User:
    def send(self, message):
        self.chat_room.send_message(message, self)
```

Mediator: **??**
Colleagues: **??**

---

**Answer:**


---

## Question 16.9

(T/F) This explains the difference between Mediator and Observer patterns correctly.

**Mediator**: **Bidirectional** communication, colleagues know mediator, **centralized** coordination.
**Observer**: **Unidirectional** notification, observers don't necessarily know each other, **decentralized** updates.

---

**Answer:**


---

## Summary

We have 9 questions on this page.

1. How many questions did you answer? ( / 9)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
