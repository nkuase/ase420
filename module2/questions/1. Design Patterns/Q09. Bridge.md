---
marp: true
---

# Q09. Bridge Pattern

---

## Question 9.1

To decouple an abstraction from its implementation so that both can vary independently.

What pattern explains this?

---

**Answer:**


---

## Question 9.2

It prevents **???** that occurs when you have multiple dimensions of variation (e.g., different shapes AND different drawing APIs would require separate classes for each combination).

What is ??? that the Bridge pattern solve?

---

**Answer:**


---

## Question 9.3

1. **Abstraction** - defines the abstraction's interface and maintains reference to Implementor
2. **RefinedAbstraction** - extends the interface defined by Abstraction
3. **Implementor** - defines interface for implementation classes
4. **ConcreteImplementor** - implements the Implementor interface
5. **Director** — implements the Bridge connection

This is a list of the main participants in the **Bridge pattern**.  
Which one is **wrong**?

---

**Answer:**


---

## Question 9.4

How does Bridge pattern prevent class explosion?

Without Bridge: N×M classes
With Bridge: ???  classes

---

**Answer:**


---

## Question 9.5

(T/F) In Bridge pattern, the abstraction and implementation can evolve independently.

---

**Answer:**


---

## Question 9.6

**Bridge**: Designed **upfront** to let abstraction and implementation vary independently.
**Adapter**: Used **after design** to make incompatible interfaces work together.

(T/F) This is the correct key difference between Bridge and Adapter patterns.

---

**Answer:**


---

## Question 9.7

- When you want to **avoid permanent binding** between abstraction and implementation
- When you have **multiple dimensions of variation**
- When changes in implementation should **not impact clients**
- When you want to **share implementation** among multiple objects
- When you need **runtime binding** of implementation
- When you want to **build complex objects step by step**

This is a list of when we should use the **Bridge pattern**.  
Which one is **wrong**?

---

**Answer:**


---

## Question 9.8

1. **Decoupling** - abstraction and implementation are independent
2. **Extensibility** - can extend abstractions and implementations separately
3. **Implementation hiding** - clients don't see implementation details
4. **Runtime binding** - can change implementation at runtime
5. **Prevents class explosion** - linear growth instead of exponential
6. **Builds complex objects step by step** — structured building complex objects

This is a list of the benefits of the **Bridge pattern**. Which one is **wrong**?

---

**Answer:**


---

## Question 9.9

In a remote control and device example, identify the Bridge components:

You have different remote controls (basic, advanced) and different devices (TV, radio).

Abstraction: **??**
Implementor: **??**
ConcreteImplementors: **??**, **??**
RefinedAbstractions: **??**, **??**

---

**Answer:**


