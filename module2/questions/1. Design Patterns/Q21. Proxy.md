---
marp: true
---

# Q21. Proxy Pattern

---

## Question 21.1

To provide a placeholder or surrogate for another object to control access to it, allowing additional functionality like lazy loading, access control, or caching.  

What pattern explains this idea?

---

**Answer:**  


---

## Question 21.2

This is a list of the different types of **proxies**.  
Which one is **wrong**?

1. **Virtual Proxy** - lazy loading, creates expensive objects on demand
2. **Protection Proxy** - access control, checks permissions before delegating
3. **Remote Proxy** - represents object in different address space
4. **Smart Proxy** - additional actions when object is accessed (reference counting, logging)
5. **Builder Proxy** — build objects without accessing the builder object

---

**Answer:**


---

## Question 21.3

This is a list of the main participants in the **Proxy pattern**.  
Which one is **wrong**?

1. **Subject** - common interface for RealSubject and Proxy
2. **RealSubject** - the actual object that proxy represents
3. **Proxy** - maintains reference to RealSubject and controls access to it
4. **Colleague** — connects between object and the proxy

---

**Answer:**


---

## Question 21.4

Complete the Virtual Proxy example for image loading:

```python
class Image:  # ??
    def display(self):
        pass

class RealImage(??1):  # ??
    def ??2(self):
        print(f"Displaying {self._filename}")

class ImageProxy(??1):  # ??
    def ??2(self):
        if self._real_image is None:
            self._real_image = RealImage(_filename)
        self._real_image.??2()
```

---

**Answer:**


---

## Question 21.5

(T/F) Proxy pattern changes the interface of the RealSubject.

---

**Answer:**


---

## Question 21.6

This is a list of when we should use the **Proxy pattern**.  
Which one is **wrong**?

- When you need **lazy initialization** of expensive objects
- When you need **access control** or security
- When you need **caching** or **smart references**
- When working with **remote objects**
- When you need **logging or monitoring** of object access
- When you need to **build complex objects step by step**

---

**Answer:**


---

## Question 21.7

What are the benefits of the Proxy pattern?

1. **Performance optimization** - lazy loading, caching
2. **Access control** - security and permission checking  
3. **Transparency** - client doesn't know it's using a proxy
4. **Additional services** - logging, monitoring, reference counting
5. **Location independence** - can represent remote objects
6. **Simplifies object creation process** — build proxy effectively

---

**Answer:**


---

## Question 21.8

This is a list of potential drawbacks of the **Proxy pattern**.  
Which one is **wrong**?

1. **Added complexity** - extra layer of indirection
2. **Performance overhead** - proxy operations can add latency
3. **Memory usage** - proxy objects consume additional memory
4. **Debugging difficulty** - harder to trace through proxy calls
5. **Prevents object extension** — Proxy prevent unnecessary extension

---

**Answer:**


---

## Question 21.9

In web development, CDN (Content Delivery Network) is used to get static content. What pattern is used?

---

**Answer:**


---

## Question 21.10

(T/F) This is the difference between Proxy and Decorator.

**Proxy**: **Controls access** to the subject, uses the **same interface**, often **manages lifecycle** of the real subject.  
**Decorator**: **Adds behavior** to the subject, uses the **same interface**, while the subject **exists independently**.  

---

**Answer:**:


---

## Summary

We have 10 questions on this page.

1. How many questions did you answer? ( / 10)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
