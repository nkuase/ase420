---
marp: true
---

# Q10. Strategy Pattern

---

## Question 10.1

To define a family of algorithms, encapsulate each one, and make them interchangeable at runtime.

What is this pattern?

---

**Answer:**


---

## Question 10.2

It eliminates large conditional statements (if/else or switch) for selecting algorithms and allows algorithms to vary independently from clients that use them.

What pattern solves this problem?

---

**Answer:**


---

## Question 10.3

1. **Strategy** - interface common to all concrete strategies
2. **ConcreteStrategy** - implements specific algorithms using Strategy interface
3. **Context** - maintains reference to Strategy object and delegates algorithm execution
4. **Director** — manages the algorithms

This is a list of the main participants in the **Strategy pattern**.  
Which one is **wrong**?

---

**Answer:**


---

## Question 10.4

Complete the Strategy pattern implementation:

```python
class PaymentStrategy:
    def pay(self, amount):
        pass

class CreditCardPayment(???):
    def pay(self, amount):
        print(f"Paid ${amount} with credit card")

class ShoppingCart:
    def __init__(self, strategy):
        self._strategy = ???
    
    def checkout(self, amount):
        # chooses the stratgy algorithm
        self._strategy.???(amount)
```

---

**Answer:**


---

## Question 10.5

(T/F) Strategy pattern is an alternative to inheritance for varying algorithms.

---

**Answer:**


---

## Question 10.6

**Strategy**: Uses **composition**, entire algorithms are interchangeable, runtime algorithm selection.
**Template Method**: Uses **inheritance**, defines algorithm skeleton with steps overridden by subclasses.

This is the difference between Strategy and Template Method patterns.

---

**Answer:**


---

## Question 10.7

- When you have **multiple ways** to perform a task
- When you want to **avoid conditional statements** for algorithm selection
- When algorithms should be **interchangeable** at runtime
- When you want to **isolate** algorithm implementation from clients
- When algorithms have **different performance characteristics**
When you need to **build complex objects step by step**

This is a list of when we should use the **Strategy pattern**.  
Which one is **wrong**?

---

**Answer:**


---

## Question 10.8

1. **Runtime algorithm selection** - can change behavior dynamically
2. **Eliminates conditionals** - no large if/else statements
3. **Open/Closed Principle** - can add new strategies without changing existing code
4. **Better testability** - can test each strategy independently
5. **Code reuse** - strategies can be reused across different contexts
6. **Guarantees a single instance** — we can choose the best one

This is a list of the benefits of the **Strategy pattern**.  
Which one is **wrong**?

---

**Answer:**


---

## Question 10.9

- **Increased number of objects** - many strategy objects
- **Client complexity** - clients must understand different strategies
- **Communication overhead** - context and strategy must share data
- **Cannot add new algorithms** — Strategy makes it *hard* to add new ones  

This is a list of potential drawbacks of the **Strategy pattern**.  
Which one is **wrong**?

---

**Answer:**


---

## Summary

We have 9 questions on this page.

1. How many questions did you answer? ( / 9)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
