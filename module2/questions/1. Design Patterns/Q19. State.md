---
marp: true
---

# Q19. State Pattern

---

## Question 1

To allow an object to alter its behavior when its internal state changes, making it appear as if the object changed its class.  

What pattern explains this idea?

---

**Answer:**  


---

## Question 2

What pattern does this problem solve?

It eliminates **large conditional statements** (if/else, switch) that depend on object state and makes state-dependent behavior more maintainable and extensible.

---

**Answer:**


---

## Question 3

This is a list of the main participants in the **State pattern**.  
Which one is **wrong**?

1. **Context** - maintains instance of ConcreteState and delegates state-specific behavior
2. **State** - interface for encapsulating behavior associated with a particular state
3. **ConcreteState** - implements specific behavior for each state of the Context
4. **Invoker** — calls the correct State

---

**Answer:**


---

## Question 4

Complete the State pattern for a traffic light:

- The initial state is RedState.
- With the change() method, the state is updated to the other state.

```python
class TrafficLightState:  # ??
    def handle(self, light): pass

class RedState(??1):  # ??
    def handle(self, light): light.set_state(??2)
class GreenState(??1): ...

# State manager
class TrafficLight:  # ??
    def __init__(self):
        self._state = ??3()
    def set_state(self, state):
        self._state = ??4
    def change(self):
        self._state.??5(self)
```

---

**Answer:**


---

## Question 5

How do you use the State pattern?

```python
class TrafficLight:
    def change(self, light): ...

traffic_light = ??()

# Change states
traffic_light.??()  # Red -> Green
traffic_light.??()  # Green -> Red  
```

---

**Answer:**


---

## Question 6

(T/F) In State pattern, the Context class contains large conditional statements to handle different states.

---

**Answer:**


---

## Question 7

This is a list of when we should use the **State pattern**.  
Which one is **wrong**?

- When object behavior depends on its **state** and must change at runtime
- When you have **large conditional statements** that depend on object state
- When states have **complex transitions** between them
- When you want to make **state transitions explicit**
- When you need to **share intrinsic state among many objects**

---

**Answer:**


---

## Question 8

This is a list of the benefits of the **State pattern**.  
Which one is **wrong**?

1. **Eliminates conditionals** - no large if/else statements
2. **Makes state transitions explicit** - clear state change logic
3. **Encapsulates state behavior** - each state handles its own behavior
4. **Easy to add states** - can add new states without changing existing code
5. **Single Responsibility** - each state class has one responsibility
6. **Minimizes memory usage** — small states lead to small memory usage

---

**Answer:**


---

## Question 9

This is a list of potential drawbacks of the **State pattern**.  
Which one is **wrong**?

1. **Increased number of classes** - one class per state
2. **Context-state coupling** - states often need to know about context
3. **State transitions complexity** - managing transitions can become complex
4. **Overkill for simple states** - unnecessary for simple state machines
5. **Prevents adding new states** — state makes it hard to add new states  

---

**Answer:**


---

## Question 10

(T/F) This is the difference between State and Strategy pattern.

**State**: States **transition** between each other, behavior changes based on **internal state**, context **unaware** of current strategy.  
**Strategy**: Strategies are **independent**, behavior chosen by **client**, context **aware** of current strategy.  

---

**Answer:**  


---

## Summary

We have 10 questions on this page.

1. How many questions did you answer? ( / 10)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
