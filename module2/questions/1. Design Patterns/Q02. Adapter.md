---
marp: true
---

# Q02. Adapter Pattern

---

## Question 2.1

What these examples demonstrate the concept of the which design pattern?

- **Power Adapter** → Converts U.S. 110V to EU 220V
- **HDMI to VGA** → Connects new laptop to old projector

---

**Answer:**


---

## Question 2.2

What is the design pattern that solves this main problem?

How to make **incompatible interfaces** work together and **reuse existing code** without modifying it.

---

**Answer:**


---

## Question 2.3

In the Banner-Print example, complete the adapter usage when we have the adaptor PrintBanner:

Old class: `Banner("Hello").show_with_paren()`
New interface: `Print("Hello").print_weak()`
Goal: Reuse old code (Banner) without rewriting

```python
# We want to use the new Print interface
print_obj = ??(Banner, Print)  # Adapter
print_obj.??()  # New API
```

---

**Answer:**


---

## Question 2.4

What are the main players in the Adapter pattern?

1. **??1** (new interface - Print)
2. **??2** (old class - Banner)
3. **??3** (bridges Target and Adaptee - PrintBanner)
4. **??4** uses the new interface

---

**Answer:**


---

## Question 2.5

What are the two implementation approaches for the Adapter pattern?

---

**Answer:**


---

## Question 2.6

In the inheritance-based adapter implementation, complete the code:

Banner: the old class/interface
  show_with_paren is the old method
Print: the new class/interface
  print_weak is the new interface name

```python
class PrintBanner(??, ??):
    def __init__(self, string: str):
        super().__init__(string)
    
    def print_weak(self):
        self.??()  # Adapt to old method
```

---

**Answer:**


---

## Question 2.7

In the delegation-based adapter implementation, what is the key difference from inheritance-based approach?

Banner: the old class/interface
  show_with_paren is the old method
Print: the new class/interface
  print_weak is the new interface name

```python
class PrintBanner(Print):
    def __init__(self, string: str):
        self._banner = ??(string)  # ??
    
    def print_weak(self):
        self.??()
```

---

**Answer:**


---

## Question 2.8

(T/F) The Adapter pattern can be used even when we do not have the source code.

---

**Answer:**


---

## Question 2.9

(T/F) The Adapter pattern is used for supporting legacy code by making the legacy code the Target and the new code the Adaptee.

---

**Answer:**


---

## Question 2.10

When can't we use the Adapter pattern? Give one example.

---

**Answer:**


---

## Question 2.11

(T/F) This is the main benefit of the Adapter pattern?

We can *reuse* existing code through *adaptation* by using the same *interface* with the new class, but reuse the old *code/implementation* with the old class.

---

**Answer:**


---

## Summary

We have 11 questions on this page.

1. How many questions did you answer? ( / 11)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
