---
marp: true
---

# Q2. SOLID Principles - LSP, ISP, and DIP

---

## Question 1

If B is a subtype of A, objects of type A should be replaced with objects of type B without breaking anything.

Subclasses should be substitutable for their base classes without causing unexpected behavior.

This explains one of the SOLID principles. What is it?

---

**Answer:**

---

## Question 2

I replaced a module, and it surprises me. What SOLID principle is violated?

---

**Answer:**

---

## Question 3

- You have a light bulb socket
- You can replace any light bulb (LED, incandescent, fluorescent) in the socket
- You won't be surprised - they all work the same way from the socket's perspective
- Each bulb type is substitutable for the general "light bulb" concept

What SOLID principle makes this possible?

---

**Answer:**

---

## Question 4

```python
class Intern(Employee):
    def __init__(self, name):
        super().__init__(name, None)  # No salary!
    
    def promote(self):
        raise Exception("Interns cannot be promoted")

# Problem - surprises when using as Employee:
intern = Intern("John")
print_year_salary(intern)  # ERROR: None * 12 fails!
```

How does the Intern class violate LSP? Explain the problem and propose the solution.

---

**Answer:**

---

## Question 5

1. **OCP violations**: Need if/else statements for type checking
2. **Fragile code**: Subclasses introduce unexpected behavior
3. **Surprising failures**: Code breaks when using subclasses
4. **Increased complexity**: More conditional logic to handle special cases
5. **Explosion of classes**: We need to add more classes

This is a list of the consequences of LSP violations. Which is not correct?

---

**Answer:**

---

## Question 6

Clients should not be forced to depend on interfaces they don't use.
Split large interfaces into smaller, more specific ones so classes only implement what they actually need.

Which SOLID principle does this idea explain?

---

**Answer:**

---

## Question 7

```python
class Worker:
    def work(self): pass
    def eat(self): pass
    def sleep(self): pass

class Robot(Worker):
    def work(self): return "Working"
    def eat(self): raise Exception("Robots don't eat!")  # Forced to implement
    def sleep(self): raise Exception("Robots don't sleep!")  # Forced to implement
```

This is an example of ISP violation. Show how to fix it.

---

**Answer:**

---

## Question 8

- High-level modules should not depend on low-level modules
- Both should depend on abstractions
- Abstractions should not depend on details

Depend on abstractions (interfaces), not concrete implementations.

What SOLID principle explains this idea?

---

**Answer:**

---

## Question 9

This is problematic code with high coupling:

**Problem (high coupling):**

```python
class Reporting:
    def __init__(self):
        self.printer = LaserPrinter()  # Depends on concrete class
```

Explain how DIP can solve this coupling issue.

**Solution**

```python
class Reporting:
    def __init__(self, printer):  # Depends on abstraction
        self.printer = printer  # Any Printer implementation

# Usage:
reporting = Reporting(LaserPrinter())  # Inject dependency
# or
reporting = Reporting(CashRegisterPrinter())  # Easy to swap!
```

**Answer:**

---

## Question 10

1. **Loose coupling**: Modules don't depend on concrete implementations
2. **Easy to swap**: Can change implementations without modifying dependent code
3. **More testable**: Can inject mock objects for testing
4. **Flexible design**: Support for multiple implementations
5. **Reduced change impact**: Changes to low-level modules don't affect high-level ones
6. **Simplicity**: Code becomes simple and easy to understand.

This is a list of the benefits of applying the Dependency Inversion Principle. Which one is wrong?

**Answer:**

---

## Question 11

How do all five SOLID principles work together to create better software design? Explain with your own words as if you were explaining the concepts to your co-workers.

---

**Answer:**

---

## Summary

We have 11 questions on this page.

1. How many questions did you answer? ( / 11)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.