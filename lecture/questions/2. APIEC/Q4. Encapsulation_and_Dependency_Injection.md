---
marp: true
---

# Q4. Encapsulation and Dependency Injection

---

## Question 4.1

What does it mean to bundle data and methods that operate on that data within a single unit (class), and control access to that data?

(Hint: It is the E of APIE)

---

**Answer:**

---

## Question 4.2

- Data is protected from direct external access
- Internal implementation can change without affecting external code
- Clearer interfaces between different parts of the system
- Better code organization and maintainability
- Reducing complexity by making a supporting method for a member field.

This is a list of the benefits of encapsulation. Which is wrong?

---

**Answers:**

---

## Question 4.3

This issue occurs when modules or classes are tightly coupled, meaning that one change impacts all the entities that are connected to them. (Hint: It also starts with C).

---

**Answer:**

---

## Question 4.4

This is a list of problems of coupling. Which is not correct?

- Changes in one module require changes in other modules
- Makes code more complicated to test independently
- Reduces the reusability of components
- Creates complex dependencies that are hard to manage
- Coupling is an easy-to-fix code smell

---

**Answer:**

---

## Question 4.5

This is the code structure.

- `main.py` imports from `report.py`
- `report.py` tries to access objects from `main.py`
- This creates a circular reference where each module needs the other

How do we call this situation?

---

**Answer:**

---

## Question 4.6

We access an object and manipulate it; this is changed because we are given (i.e., injected) an object to manipulate. What's the idea of calling this idea? (Hint: We see the dependency is injected)

---

**Answer:**

---

## Question 4.7

Explain how "Dependency Injection" solves coupling problems?

---

**Answer:**

---

## Question 4.8

This is a list of the coupling solutions. Which is not correct?

- Objects don't need to know where dependencies come from
- Dependencies are "injected" into the object when needed
- Removes direct coupling between modules
- Makes code more flexible and testable
- Makes more tests to find bugs as early as possible

---

**Answer:**

---

## Question 4.9

This is Python code. Explain how this Python code implements dependency injection for a report class. In other words, what is injected?

**Before (coupled)**:

```python
class AccountingReport:
    def print_report(self): # Directly accessing external data - BAD!
        for e in employees:  # coupling!
            print(f"{e.name}, ${e.salary}")
```

**After (dependency injection)**:

```python
class AccountingReport:
    def __init__(self, emp_list): self._emp_list = emp_list  # Injected dependency
    def print_report(self):
        for e in self._emp_list:
            print(f"{e.name}, ${e.salary}")
```

---

**Answer:**

---

## Question 4.10

Explain how dependency injection is used in this main module.

```python
from reporting import AccountingReport

employees = [...]  # Create employee list

# Inject the dependency when creating the object
accounting_report = AccountingReport(employees)
accounting_report.print_accounting_report()
```

---

**Answer:**

---

## Question 4.11

In UML diagrams, how do you represent coupling versus dependency injection? (Hint: Do you remember when we used solid/dotted lines in UML?)

---

**Answer:**

---

## Question 4.12

1. **Reduced coupling**: Objects don't access dependencies directly
2. **Improved testability**: Dependencies can be easily mocked or replaced
3. **Better flexibility**: Different implementations can be injected
4. **Cleaner code**: Clear separation between object creation and usage
5. **Easier maintenance**: Changes to dependencies don't require changing the class
6. **Reusability**: Classes can work with different data sources
7. **Better Abstraction**: We can see objects and their relationship easily

This is a list of the key benefits of using dependency injection. Which is wrong?

---

**Answer:**

---

## Summary

We have 12 questions on this page.

1. How many questions did you answer? ( / 12)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.